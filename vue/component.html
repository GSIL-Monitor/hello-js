<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Component</title>

    <script src="https://cdn.jsdelivr.net/npm/vue"></script>

    <style>
        .demo-alert-box {
            padding: 10px 20px;
            background: #f3beb8;
            border: 1px solid #f09898;
        }
    </style>
</head>

<body>
    <div id="button-counter-demo">
        <button-counter v-bind="test"></button-counter>
        <button-counter></button-counter>
        <button-counter></button-counter>
    </div>
    <script>
        Vue.config.devtools = true;
        // 全局注册组件，一个组件只能有一个根元素，组件名字母全小写且必须包含一个连字符
        Vue.component('button-counter', {
            props: ['a','b'],
            // 组件的data必须是函数，每个组件实例维护一份独立的数据
            data: function() {
                return {
                    count: 0
                }
            },
            template: '<button v-on:click="count++">You clicked me {{ count }} times. {{a}},{{b}}</button>'
        });
        let buttonCounterDemo = new Vue({
            el: '#button-counter-demo',
            data: {
                test:{
                    a:1,
                    b:2
                }
            }
        });
    </script>

    <!-- 通过props向子组件传递数据 v-bind -->
    <!-- @enlarge-text="onEnlargeText" 监听组件内部触发的事件，可通过$event访问到传递的参数 -->
    <div id="blog-post-demo">
        <div :style="{ fontSize: postFontSize+'em'}">
            <blog-post
                v-for="post in posts"
                :key="post.id"
                :post="post"
                @enlarge-text="onEnlargeText"
            ></blog-post>
        </div>
    </div>
    <script>
        // 通过props向子组件传递数据
        Vue.component('blog-post', {
            props: [ 'post' ],
            // 通过$emit(name, arg)向父级组件发送一个事件，事件名推荐使用kebab-case
            template: `
            <div id="custom-input-demoblog-post">
                <h3>{{post.title}}</h3>
                <button @click="$emit('enlarge-text', 0.1)">Enlarge text</button>
                <div v-html="post.content"></div>
            </div>`,
        });
        let blogPostDemo = new Vue({
            el: '#blog-post-demo',
            data: {
                posts: [{
                        id: 1,
                        title: 'My journey with Vue',
                        content: '...content...'
                    },
                    {
                        id: 2,
                        title: 'Blogging with Vue',
                        content: '...content...'
                    },
                    {
                        id: 3,
                        title: 'Why Vue is so fun',
                        content: '...content...'
                    }
                ],
                postFontSize: 1,
            },
            methods: {
                onEnlargeText: function (enlargeAmount) {
                    this.postFontSize += enlargeAmount;
                }
            }
        });
        // 通过props传递数据，数据流是单向的，只能由父组件到子组件
        // 如果想要实现双向绑定，可以用 .sync 修饰符
        // v-bind:name.sync="myName"  v-bind.sync="obj"
        // 然后在子组件中，发送一个update事件 this.$emit('upodate:name', newVal);
    </script>

    <!-- 在组件上使用v-model -->
    <div id="custom-input-demo">
        <custom-input v-model="searchText" :label="label" @focus="console.log(event.target.value)" some-attrs="aaa"></custom-input>
        <p>{{searchText}}</p>
        <custom-checkbox v-model="foo" value="some value"></custom-checkbox>
    </div>
    <script>
        // 在组件中使用v-model
        // <input v-model="searchText">
        // 等价于
        // <input v-bind:value="searchText" v-on:input="searchText = $event.target.value">
        // 而用在组件上时， v-model则会这样
        // <custom-input v-bind:value="searchText" v-on:input="searchText = $event"></custom-input>
        // 为了让其正常工作，这个组件内的input必须：
        // 1.将其 value 属性绑定到一个名叫 value 的 prop 上
        // 2.在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出
        Vue.component('custom-input', {
            // 默认情况下，不被props识别的属性将会自动继承到组件的根元素上，设置为false时，跟元素不会继承这些属性
            inheritAttrs: false,
            props: ['label','value'],
            // 如果需要发出多个事件，可以和$listeners合并到一个对象里，然后v-on="对象"
            computed: {
                inputListeners: function() {
                    let vm = this;
                    return Object.assign({}, this.$listeners, {
                        input: function(event) {
                            vm.$emit('input', event.target.value);
                        },
                        focus: function(event) {
                            vm.$emit('focus');
                        }
                    })
                }
            },
            // 使用 v-bind=$attrs 可以在非根元素上继承不被props识别的属性(一般配合inheritAttrs:false使用)
            // input不是根元素，所以想在 custom-input 标签中监听输入框的原生事件(例如input)时
            template: `
            <label>
                {{label}}
                <input
                    v-bind=$attrs
                    v-bind:value="value"
                    v-on="inputListeners"
                />
            </label>`
        });
        Vue.component('custom-checkbox', {
            // 默认情况下v-model会把实例的属性绑定到value，event为input
            // model字段允许自定义组件在使用v-model时定制绑定的属性prop和event
            model: {
                prop: 'checked',
                event: 'change',
            },
            props: {
                checked: Boolean,
                // value 可以用作其他用途了
                value: String
            },
            template: `
            <label>
                <input
                    type="checkbox"
                    v-bind:checked="checked"
                    v-on:change="$emit('change', $event.target.checked)"
                />
                {{value}}
            </label>`
        })
        let customInputDemo = new Vue({
            el: '#custom-input-demo',
            data: {
                label: 'input:',
                searchText: 'emm...',
                foo: true,
            }
        })
    </script>

    <!-- slot插槽分发内容 -->
    <div id="alert-box-demo">
        <alert-box> <span slot="my-slot">Something bad happened.</span> </alert-box>
    </div>
    <script>
        // slot插槽分发内容
        // 插槽可以有多个，这时需要为slot指定name，
        // 在使用组件时，需要指定slot="slot-name"来分配到不同插槽，没有分配到的会分配到默认插槽(没有name的插槽)
        Vue.component('alert-box', {
            template: `
            <div class="demo-alert-box">
                <strong>Error!</strong>
                <slot name="my-slot">default contents</slot>
            </div>`
        });
        let alertBoxDemo = new Vue({
            el: '#alert-box-demo'
        });
    </script>


    <!-- 可以通过slot-scope来获取插槽里v-bind的变量作用域 -->
    <!-- 相当于从组件里获取数据 -->
    <div id="todo-list-demo">
        <todo-list :todos="todos">
            <template slot-scope="slotProps">
                <span  v-if="slotProps.mytodo.isComplete">✔️</span>
                {{ slotProps.mytodo.text }}
            </template>

        </todo-list>
    </div>
    <script>
        Vue.component('todo-list', {
            props:['todos'],
            template: `<ul>
              <li
                v-for="todo in todos"
                v-bind:key="todo.id"
              >
                <slot v-bind:mytodo="todo">
                  {{ todo.text }}
                </slot>
              </li>
            </ul>`
        });
        let todoListDemo = new Vue({
            el: '#todo-list-demo',
            data: {
                todos: [{
                        id:1,
                        text: '学习 JavaScript',
                        isComplete: true,
                    },
                    {
                        id:2,
                        text: '学习 Vue',
                        isComplete: false,
                    },
                    {
                        id:3,
                        text: '学习 aaa',
                        isComplete: true,
                    },
                ]
            }
        });
    </script>


    <!-- 动态组件 -->
    <!-- v-bind:is="computedAttr" 来绑定显示哪个组件 -->
    <!-- 可以用 keep-alive 标签包裹 component 标签，这样切换回来不会重构 -->
    <div id="dynamic-component-demo">
        <button v-for="tab in tabs" @click="currentTab=tab">{{tab}}</button>
        <component v-bind:is="currentTabComponent"></component>
    </div>
    <script>
    Vue.component('tab-home', {
        template: '<p>Home component</p>'
    });
    Vue.component('tab-posts', {
        template: '<p>Posts component</p>'
    });
    Vue.component('tab-archive', {
        template: '<p>Archive component</p>'
    });
    let dynamicComponentDemo = new Vue({
        el: '#dynamic-component-demo',
        data: {
            currentTab: 'Home',
            tabs: ['Home', 'Posts', 'Archive']
        },
        computed: {
            currentTabComponent: function() {
                return 'tab-' + this.currentTab.toLowerCase();
            }
        },
    });
    </script>


    <script>
    // 局部注册组件
    // 如果不再使用某个全局注册的组件，它始终会包含在构建结果中增加js体积
    // 用对象定义组件
    // var ComponentA = { /* ... */ }
    // var ComponentB = { /* ... */ }
    // var ComponentC = { /* ... */ }
    // 然后在components选项中定义需要的组件，注意平级组件之间不可相互调用
    // new Vue({
    //     el: '#app'
    //     components: {
    //         'component-a': ComponentA,
    //         'component-b': ComponentB
    //     }
    // })

    // 如果在ComponentB.js中使用ComponentA和ComponentC
    // ComponentB.js如下
    // import ComponentA from './ComponentA'
    // import ComponentC from './ComponentC'
    //
    // export default {
    //     components: {
    //         ComponentA,
    //         ComponentC
    //     },
    //     // ...
    // }

    // 基础组件自动化全局注册https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C


    // props中的变量名要会出现在html属性中，而属性不区分大小写，所以用kebab-case(短横线分隔)命名
    // 可以指定变量的类型、验证要求，没有满足要求会在控制台发出警告
    // props: {
    //     title: String,
    //     likes: [Number, Date, Function, Symbol],
    //     isPublished: Boolean,
    //     commentIds: Array,
    //     author: Object,
    //     propA: {
    //         type: Number,    // 类型，可以是个构造函数
    //         required: true,  // 必填字段
    //         default: 100,    // 默认值，如果是对象、数组，必须从一个函数返回
    //         validator: function(value) {
    //             // 自定义验证函数，value必须是数组中的一个
    //             // 验证失败时，开发环境下回再控制台产生警告
    //             // props会在实例创建之前进行验证，所以validator和default里不能用data、computed等
    //             return ['success', 'warning', 'danger'].indexOf(value) !== -1;
    //         }
    //     },
    //     propB: {
    //         type: Object,
    //         defaut: function(){
    //             return {};
    //         },
    //     }
    // }

    // 不应该在一个子组件内部修改prop的值，最好定义一个本地data属性接受prop传来的初始值，然后改变data中的值
    // 数组、对象通过引用传入，直接赋值再修改还是会导致父组件内容被修改


    // provide和inject实现依赖注入。
    // provide指定我们想要提供给后代组件的数据/方法
    // provide: function() {
    //     return {
    //         getMap: this.getMap
    //     }
    // }
    // 在后代组件里可以用inject来接收指定的属性
    // inject: ['getMap']
    </script>


</body>

</html>
