<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>Vue</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
</head>

<body>
    <!-- v-bind -->
    <!-- v-bind缩写 :title="mytitle" 绑定class时还可以传入对象或数组 -->
    <!-- isActive为true时，div有active类 -->
    <div id="app" v-bind:title="mytitle" :class="{ active: isActive }">
        <!-- mustache语法会将值解释为文本，即使他是一段html -->
        <p>mustache语法 : {{ message }}</p>
        <!-- v-html 指令可以将值解释为html代码，注意不要对用户提供的内容进行渲染以导致xss攻击 -->
        <p>v-html指令 : <span v-html="message"></span></p>
        <!-- v-once指令只会初次渲染，之后改变数据值不会更新 -->
        <p v-once>这里的值不会随message而改变 : {{message}}</p>
    </div>
    <script>
        // 启用chrome vue devtools
        Vue.config.devtools = true;
        // v-bind
        let app = new Vue({
            el: '#app',
            data: {
                message: '<span style="color:red">This should be red.</span>',
                mytitle: '页面加载于 ' + new Date().toLocaleString(),
                isActive: true,
            }
        });
    </script>


    <!-- v-if v-else v-else-if -->
    <div id="app-2">
        <p v-if="seen">能看到</p>
        <p v-else>看不到</p>
    </div>
    <script>
        // v-if
        let app2 = new Vue({
            el: '#app-2',
            data: {
                seen: false,
            }
        });
    </script>


    <!-- v-for="(item, index) in array" 或者用 of 代替 in -->
    <!-- v-for="(value, key, index) in object" -->
    <!-- 遍历是按照Object.keys()的结果进行的 -->
    <!-- 用 v-bind:key="item.id" 来让Vue跟踪每个节点的身份 -->
    <!-- v-for:"n in 10"  1~10 -->
    <!-- v-for 和 v-if 在同级时，for 优先级高，if会在每个for中执行 -->
    <div id="app-3">
        <ol>
            <li v-for="todo in todos">
                {{ todo.text }}
            </li>
        </ol>
    </div>
    <script>
        // v-for
        let app3 = new Vue({
            el: '#app-3',
            data: {
                todos: [{
                        text: '学习 JavaScript'
                    },
                    {
                        text: '学习 Vue'
                    },
                    {
                        text: '学习 aaa'
                    },
                ]
            }
        });
    </script>


    <!-- v-on 监听事件 -->
    <!-- v-on缩写 @click="reverse" -->
    <div id="app-4">
        <p> {{ message }} </p>
        <button type="button" name="button" v-on:click="reverse" v-bind:disabled="isDisabled">倒置</button>
    </div>
    <script>
        // v-on
        let app4 = new Vue({
            el: '#app-4',
            data: {
                message: 'Hello Vue.',
                isDisabled: false,
            },
            methods: {
                reverse: function() {
                    this.message = this.message.split('').reverse().join('');
                },
            },
        });
    </script>


    <!-- v-model表单输入绑定 watch侦听属性-->
    <div id="app-5">
        <p>total: {{ total }} </p>
        num: <input type="number" v-model="num" value="" />
        <br/>
        <select v-model="selected">
            <option disabled value="">请选择</option>
            <option value="a">A</option>
            <option value="b">B</option>
            <option value="c">C</option>
        </select>
        <span>Selected: {{ selected }}</span>
    </div>
    <script>
        // v-model watch侦听属性，需要在数据变化时执行异步操作或开销较大的操作时，使用watch
        let app5 = new Vue({
            el: '#app-5',
            data: {
                num: 5,
                total: 50,
                selected: ''
            },
            watch: {
                num: function(newVal, oldVal) {
                    this.total = newVal * 10;
                }
            }
        });
    </script>


    <!-- computed 计算属性-->
    <div id="app-7">
        <p>message: {{message}}</p>
        <p>reverseMessage: {{reverseMessage}}</p>
    </div>
    <script>
        // computed
        // 计算属性基于他们的依赖进行结果的缓存，只要依赖不改变，多次访问就会直接返回结果
        // 而如果用methods，则需要每次都执行方法返回结果
        // 上面的watch例子用computed改写更好
        let app7 = new Vue({
            el: '#app-7',
            data: {
                message: 'hello',
            },
            computed: {
                reverseMessage: function() {
                    return this.message.split('').reverse().join('');
                }
            }
        });
    </script>


    <!-- 组件的 v-for ，不能将item自动注入组件，需要使用props -->
    <div id="todo-list">
        <form @submit.prevent="addNewTodo">
            <label for="new-todo">Add a todo</label>
            <input v-model="newTodoText" type="text" id="new-todo" placeholder="E.g. Feed the cat">
            <button>Add</button>
        </form>
        <ul>
            <!-- 因为只有li才能直接出现在ul内部，如果直接使用todo-item标签会解析出错，因此用is指定模板 -->
            <li is="todo-item" v-for="(todo, index) in todos" :key="todo.id" :title="todo.title" @remove="todos.splice(index,1)"></li>
        </ul>
    </div>
    <script>
        Vue.component('todo-item', {
            template: `<li>{{title}} <button @click="$emit('remove')">Remove</button> </li>`,
            props: ['title'],
        });

        let todoList = new Vue({
            el: '#todo-list',
            data: {
                newTodoText: '',
                todos: [{
                        id: 1,
                        title: 'Do the dishes'
                    },
                    {
                        id: 2,
                        title: 'Take out the trash'
                    },
                    {
                        id: 3,
                        title: 'Mow the lawn'
                    },
                ],
                nextTodoId: 4,
            },
            methods: {
                addNewTodo: function() {
                    this.todos.push({
                        id: this.nextTodoId++,
                        title: this.newTodoText,
                    });
                    this.newTodoText = ''
                },
            },
        });
    </script>

    <!-- 事件修饰符 可以串联，可以只有修饰符-->
    <!-- @click.stop="doThis" 阻止事件继续传播 -->
    <!-- @submit.prevent="onSubmit" 提交事件不再重载页面 阻止默认事件-->
    <!-- @click.capture="doThis" 在事件捕获阶段处理 -->
    <!-- @click.self="doThat" event.target是当前元素时触发处理函数 -->
    <!-- @click.once="doThis" 点击事件只触发一次 -->
    <!-- @scroll.passive="onScroll"  相当于addEventListener中的passive选项，
    告诉浏览器在事件处理函数中不会调用preventDefault()，以提升滚动性能 -->

    <!-- 按键修饰符 .keyCode 或 .别名 -->
    <!-- @keyup.enter="submit"  -->
    <!-- 自带别名 .tab .delete .esc .space .up .down .left .right -->
    <!-- 自定义按键修饰符别名 Vue.config.keyCodes.f1 = 112 -->

    <!-- 系统修饰键 仅在按下相应按键时才触发鼠标或键盘事件的监听器 -->
    <!-- @keyup.alt.67  alt+c -->
    <!-- @click.ctrl="doSomething"  ctrl+click -->
    <!-- .ctrl .alt .shift .meta -->
    <!-- .exact 为精确模式，不能按下别的系统键 -->

    <!-- 鼠标按键修饰符 .left .right .middle -->
    <!-- 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 -->

    <!-- v-model.lazy="msg" 使用change事件对数据进行同步，而不是默认的input事件 -->
    <!-- v-model.number="age" 自动转换为数值类型 -->
    <!-- v-model.trim="msg" 自动过滤首尾空白符 -->

    <script>
        // 由于 JavaScript 的限制，Vue 不能检测以下变动的数组：
        // 1.当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue
        // 2.当你修改数组的长度时，例如：vm.items.length = newLength
        // 解决：
        // 1.Vue.set() vm.$set(vm.array, indexOfItem, newValue) 或用 splice
        // 2.vm.items.splice(newLength)

        // 还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：
        // 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性，即data里面直接定义的属性
        // 可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性 Vue.set(vm.obj, key, value)
        // 使用Object.assign()添加多个属性时，应该新建对象赋值给原对象，如下
        // vm.obj = Object.assign({}, vm.obj, {newkey1:newvalue1, newkey2:newvalue2})
    </script>
</body>

</html>
